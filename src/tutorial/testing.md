# 테스트

수십 년 동안 소프트웨어 개발을 해온 사람들은
한 가지 진리를 발견했습니다.
테스트되지 않은 소프트웨어는 거의 작동하지 않습니다.
(많은 사람들이 말할 수 있습니다.
"테스트된 소프트웨어도 대부분 작동하지 않습니다."
하지만 우리는 모두 낙관주의자죠, 맞죠?)
따라서 프로그램이 기대하는 대로 작동하도록 하려면
테스트하는 것이 좋습니다.

그렇게 하기 위한 쉬운 방법은
프로그램이 무엇을 해야 하는지 설명하는 `README` 파일을 작성하는 것입니다.
그리고 새로운 버전을 출시할 준비가 되었을 때,
`README`를 살펴보고
동작이 여전히 기대대로 유지되는지 확인하십시오.
잘못된 입력에 대해 프로그램이 어떻게 반응해야 하는지도 적어두면
더 철저한 연습이 될 수 있습니다.

다음은 또 다른 멋진 아이디어입니다.
코드를 작성하기 전에 그 `README`를 작성하십시오.

<aside>

**참고:**
테스트 주도 개발에 대해 알아보지 않았다면
[테스트 주도 개발](https://ko.wikipedia.org/wiki/테스트_주도_개발)을 참조하십시오.


</aside>

## 자동화된 테스트

이제까지는 잘 되고 있겠지만,
모든 것을 수동으로 하는 것은?
꽤 시간이 오래 걸릴 수 있습니다.
동시에,
많은 사람들이 컴퓨터에게 일을 하도록 지시하는 것을 즐기게 되었습니다.
테스트를 자동화하는 방법에 대해 알아보겠습니다.

Rust는 내장된 테스트 프레임워크를 가지고 있으므로,
첫 번째 테스트를 작성해 보겠습니다:

```rust,ignore
# fn answer() -> i32 {
#   42
# }
#
#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
```

이 코드 스니펫을 거의 모든 파일에 넣을 수 있으며
`cargo test`가 찾아서 실행합니다.
핵심은 `#[test]` 속성입니다.
이 속성을 통해 빌드 시스템이 이러한 함수를 찾아 테스트로 실행하고
panic하지 않는지 확인할 수 있습니다.

<aside class="exercise">

**독자를 위한 연습:**
이 테스트를 작동하게 하세요.

다음과 같은 출력이 나오도록 해야 합니다.

```text
running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

</aside>

이제 테스트를 *어떻게* 작성하는지 알았으므로,
*무엇을* 테스트해야 하는지 알아야 합니다.
보셨듯이 함수에 대한 단언을 작성하는 것은 상대적으로 쉽습니다.
하지만 CLI 애플리케이션은 종종 하나의 함수 이상으로 구성됩니다!
더 나아가 사용자 입력, 파일 읽기 및 출력 작성과 같은 작업을 처리하는 경우가 많습니다.

## 코드를 테스트 가능하게 만들기

함수의 기능을 테스트하는 데 두 가지 보완적인 접근 방식이 있습니다.

* 작은 단위를 테스트하는 방법: 이를 '단위 테스트'라고 합니다.
* 완전한 애플리케이션을 '외부'에서 테스트하는 방법: 이를 '검은 상자 테스트' 또는 '통합 테스트'라고 합니다.

먼저 첫 번째 방법에 대해 알아보겠습니다.

테스트해야 할 내용을 파악하기 위해 프로그램의 기능을 살펴보겠습니다.
주로 `grrs`는 주어진 패턴에 맞는 줄을 출력하도록 설계되었습니다.
따라서 이 _정확히_에 대한 단위 테스트를 작성해야 합니다.
가장 중요한 논리 부분이 제대로 작동하는지 확인하고 싶으며, CLI 인수와 같은 주변 코드에 의존하지 않고 이를 수행해야 합니다.

처음에 작성한 `grrs`의 [첫 번째 구현](impl-draft.md) 에서 `main` 함수에 다음 코드 블록을 추가했습니다.

```rust,ignore
// ...
for line in content.lines() {
    if line.contains(&args.pattern) {
        println!("{}", line);
    }
}
```

안타깝게도 이것은 테스트하기가 매우 어렵습니다.
첫째, 메인 함수에 있기 때문에 쉽게 호출할 수 없습니다.
이것은 코드를 함수로 옮겨서 쉽게 해결할 수 있습니다.

```rust,no_run
fn find_matches(content: &str, pattern: &str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!("{}", line);
        }
    }
}
```

이제 우리는 이 함수를 테스트에서 호출하고, 그 출력을 볼 수 있습니다:

```rust,ignore
#[test]
fn find_a_match() {
    find_matches("lorem ipsum\ndolor sit amet", "lorem");
    assert_eq!( // uhhhh
```

아니요… 아니면 어떻게 할 수 있을까요?
지금 `find_matches`는 직접 `stdout` (터미널)로 출력합니다.
우리가 이를 테스트에서 쉽게 캡처할 수는 없습니다!

이것은 구현 후 테스트를 작성할 때 자주 발생하는 문제입니다.
우리는 사용되는 맥락에 깊이 결합된 함수를 작성했습니다.

<aside class="note">

**참고:**
작은 CLI 애플리케이션을 작성할 때는 이것이 완벽합니다.
모든 것을 테스트 가능하게 만들 필요는 없습니다!
하지만 코드의 어떤 부분을 단위 테스트로 작성할지 고려하는 것이 중요합니다.
우리가 이 함수를 테스트 가능하게 변경하는 것이 쉬운 것처럼 보이지만,
항상 그런 것은 아닙니다.

</aside>

그렇다면 이것을 테스트 가능하게 어떻게 만들 수 있을까요?
어떻게든 출력을 캡처해야 합니다.
Rust의 표준 라이브러리는 입력/출력(I/O)을 처리하는 데 유용한 추상화를 제공하며, 우리는 `std::io::Write`라고 불리는 것을 사용할 것입니다.
`std::io::Write`는 우리가 쓸 수 있는 것에 대한 추상화를 제공하는 [trait](https://doc.rust-lang.org/book/ch10-02-traits.html)입니다. 이에는 문자열뿐만 아니라 `stdout`도 포함됩니다.

만약 이전에 Rust에서 "trait"라는 용어를 들었던 적이 없다면,
흥미로운 경험을 할 것입니다.
Trait는 Rust에서 가장 강력한 기능 중 하나입니다.
Java의 인터페이스 또는 Haskell의 타입 클래스(어떤 것이 더 익숙한지에 따라)와 같이 생각할 수 있습니다.
그들은 다양한 유형에서 공유될 수 있는 동작을 추상화할 수 있습니다.
Trait를 사용하는 코드는 매우 일반적이고 유연한 방식으로 아이디어를 표현할 수 있습니다.
이것은 동시에 이해하기 어려울 수도 있습니다.
두려워하지 마세요: Rust를 오랫동안 사용해 온 사람들조차도 일반적인 코드가 무엇을 하는지 즉시 이해하지 못하는 경우가 있습니다.
그럴 때는 구체적인 사용 사례를 생각하는 것이 도움이 됩니다.
예를 들어, 우리의 경우, 추상화하는 동작은 "쓰기"입니다.
("impl")을 구현하는 유형의 예는 다음과 같습니다.
터미널의 표준 출력, 파일, 메모리 버퍼 또는 TCP 네트워크 연결.
(`std::io::Write` [문서](https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html)에서 "Implementors" 목록을 확인하세요.)

이 지식을 바탕으로 함수를 수정하여 세 번째 매개변수를 추가합니다.
이 매개변수는 `Write`를 구현하는 유형이어야 합니다.
이렇게 하면 테스트에서 간단한 문자열을 제공하고 그에 대한 주장을 할 수 있습니다.
`find_matches`의 이 버전을 작성하는 방법은 다음과 같습니다:

```rust,ignore
{{#include testing/src/main.rs:23:29}}
```

새로운 매개변수는 `mut writer`입니다.
즉, 우리가 "writer"라고 부르는 변경 가능한 객체입니다.
그 유형은 `impl std::io::Write`이며,
"`Write` trait를 구현하는 모든 유형의 자리 표시자"로 읽을 수 있습니다.
또한 이전에 사용했던 `println!(…)`를
`writeln!(writer, …)`로 대체했다는 점에 유의하십시오.
`println!`은 `writeln!`와 동일하게 작동하지만 항상 표준 출력을 사용합니다.

이제 출력을 테스트할 수 있습니다.

```rust,ignore
{{#include testing/src/main.rs:31:36}}
```

이제 이를 애플리케이션 코드에서 사용하려면,
`main`에서 `find_matches` 함수의 호출을 변경해야 합니다.
[`&mut std::io::stdout()`][stdout]를 세 번째 매개변수로 추가해야 합니다.
다음은 이전 챕터에서 살펴본 내용을 기반으로
`find_matches` 함수를 사용하는 `main` 함수의 예입니다:

```rust,ignore
{{#include testing/src/main.rs:13:21}}
```

[stdout]: https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html

<aside class="note">

**참고:**
`stdout`는 문자열이 아닌 바이트를 기대하기 때문에,
`std::io::Write`를 `std::fmt::Write` 대신 사용합니다.
따라서 테스트에서 "작성자"로 빈 벡터를 제공합니다.
(유형은 `Vec<u8>`로 추론됩니다).
`assert_eq!`에서 `b"foo"`를 사용합니다.
( `b` 접두사는 이를 바이트 문자열 리터럴로 만듭니다.
따라서 유형은 `&[u8]`가 아니라 `&str`가 됩니다). 

</aside>

<aside class="note">

**참고:**
이 함수를 `String`을 반환하도록 만들 수도 있지만,
그렇게 하면 동작이 변경됩니다.
터미널에 직접 쓰는 대신,
모든 내용을 문자열로 모아서 끝에 한 번에 모두 출력합니다.

</aside>

<aside class="exercise">

**독자를 위한 연습:**
[`writeln!`]는 [`io::Result`]를 반환합니다.
쓰기가 실패할 수 있기 때문입니다.
예를 들어 버퍼가 가득 차서 확장할 수 없는 경우입니다.
`find_matches`에 오류 처리를 추가하세요.

[`writeln!`]: https://doc.rust-lang.org/1.39.0/std/macro.writeln.html
[`io::Result`]: https://doc.rust-lang.org/1.39.0/std/io/type.Result.html

</aside>

우리는 이제 코드를 쉽게 테스트할 수 있게 하는 방법을 보았습니다.
우리는

1. 애플리케이션의 핵심 부분 중 하나를 식별하고,
2. 그것을 자신의 함수로 묶고,
3. 더욱 유연하게 만들었습니다.

테스트 가능하도록 만들려는 목표였지만,
결과적으로 얻은 것은
실제로 매우 고유하고 재사용 가능한 Rust 코드입니다.
정말 멋지네요!

## 라이브러리 및 바이너리 타겟으로 코드 분할하기

우리는 여기에 한 가지 더 할 수 있습니다.
지금까지 작성한 모든 내용을 `src/main.rs` 파일로 넣었습니다.
이로 인해 현재 프로젝트는 하나의 바이너리를 생성합니다.
하지만 코드를 라이브러리로 제공할 수도 있습니다.

1. `find_matches` 함수를 새롭게 만든 `src/lib.rs`로 옮깁니다.
2. `fn` 앞에 `pub`를 추가하여 `pub fn find_matches`로 만듭니다.
   이렇게 하면 라이브러리를 사용하는 사용자가 함수에 액세스할 수 있습니다.
3. `src/main.rs`에서 `find_matches`를 제거합니다.
4. `fn main`에서 `find_matches` 호출 앞에 `grrs::`를 붙여 `grrs::find_matches(…)`로 만듭니다.
   이는 우리가 작성한 라이브러리에서 함수를 사용한다는 것을 의미합니다!

Rust가 프로젝트를 처리하는 방식은 매우 유연하며,
크레이트의 라이브러리 부분에 무엇을 넣을지에 대한 고려는 초기 단계에서 중요합니다.
예를 들어, 애플리케이션 고유의 논리를 위한 라이브러리를 먼저 작성하고,
CLI에서 다른 라이브러리와 마찬가지로 사용할 수 있습니다.
또는 프로젝트에 여러 바이너리가 있는 경우,
공통 기능을 해당 크레이트의 라이브러리 부분에 넣을 수 있습니다.

<aside class="note">

**참고:**
`src/main.rs`에 모든 것을 넣는 것에 대해 말씀드리자면,
이렇게 계속하면 코드를 읽기 어려워집니다.
[모듈 시스템]은 코드를 구조화하고 정리하는 데 도움이 될 수 있습니다.

[모듈 시스템]: https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html

</aside>


## CLI 애플리케이션 테스트: 실행을 통한 테스트

지금까지 우리는 애플리케이션의 _비즈니스 로직_을 테스트하는 데 집중했습니다.
이는 `find_matches` 함수였습니다.
이는 매우 중요하며, 잘 테스트된 코드베이스를 위한 좋은 시작입니다.
(일반적으로 이러한 유형의 테스트를 '단위 테스트'라고 합니다.)

그러나 우리가 테스트하지 않은 코드가 많습니다.
즉, 외부 세계와 상호 작용하는 모든 코드입니다!
만약 `main` 함수를 작성했지만, 사용자 입력 경로의 인수 대신 고정된 문자열을 남겨두었다면 어떨까요?
우리는 그런 경우에도 테스트를 작성해야 합니다!
(이러한 수준의 테스트는 종종 '통합 테스트' 또는 '시스템 테스트'라고 합니다.)

핵심은 여전히 함수를 작성하고 `#[test]`로 표시하는 것입니다.
단지 함수 내부에서 무엇을 하는지에 대한 문제입니다.
예를 들어, 프로젝트의 메인 바이너리를 사용하고 일반 프로그램처럼 실행해야 합니다.
또한 이러한 테스트를 `tests/cli.rs`와 같은 새로운 디렉토리의 새로운 파일로 넣습니다.

<aside>

**참고:**
습관적으로,
`cargo`는 통합 테스트를 `tests/` 디렉토리에서 찾습니다.
마찬가지로,
벤치마크는 `benches/`에서, 예제는 `examples/`에서 찾습니다.
이러한 규칙은 주요 소스 코드에도 적용됩니다.
라이브러리는 `src/lib.rs` 파일을 가지고 있으며,
메인 바이너리는 `src/main.rs`이며,
여러 바이너리가 있는 경우,
`cargo`는 `src/bin/<name>.rs`에서 기대합니다.
이러한 규칙을 따르면 Rust 코드를 읽는 데 익숙한 사람들에게 코드베이스가 더 쉽게 발견됩니다.

</aside>

기억하시죠? `grrs`는 파일에서 문자열을 검색하는 작은 도구입니다.
우리는 이전에 일치하는 항목을 찾을 수 있다는 것을 테스트했습니다.
다음은 테스트할 수 있는 다른 기능입니다.

- 파일이 존재하지 않을 때 어떤 일이 일어나는가?
- 일치하는 항목이 없을 때 출력은 무엇인가?
- 인수를 하나(또는 두 개) 잊어버렸을 때 프로그램은 오류로 종료되는가?

이러한 것은 모두 유효한 테스트 케이스입니다.
또한 '행복한 경로' 테스트 케이스를 포함해야 합니다.
즉, 적어도 하나의 일치하는 항목을 찾았고 출력했습니다.

이러한 유형의 테스트를 수행하기 위해 `assert_cmd` crate를 사용할 것입니다.
`assert_cmd`는 메인 바이너리를 실행하고 동작을 확인하는 데 유용한 도구를 제공합니다.
또한 `predicates` crate를 추가하여 `assert_cmd`가 테스트할 수 있는 주장과 훌륭한 오류 메시지를 제공하는 데 도움이 됩니다.
이러한 의존성은 `Cargo.toml`의 '개발 의존성' 섹션에 추가됩니다.
이들은 crate를 개발할 때만 필요하며, 사용할 때는 필요하지 않습니다.

```toml
{{#include testing/Cargo.toml:16:18}}
```

[`assert_cmd`]: https://docs.rs/assert_cmd
[`predicates`]: https://docs.rs/predicates

이렇게 설정하는 것은 많이 복잡해 보입니다.
그럼에도 불구하고
바로 시작하여 `tests/cli.rs` 파일을 만들어 보겠습니다:

```rust,ignore
{{#include testing/tests/cli.rs:1:15}}
```

위 테스트를 `cargo test` 명령어로 실행할 수 있습니다.
위에서 작성한 테스트와 마찬가지로 실행됩니다.
처음에는 조금 더 오래 걸릴 수 있습니다.
`Command::cargo_bin("grrs")`가 메인 바이너리를 컴파일해야 하기 때문입니다.

## 테스트 파일 생성


지금까지 본 테스트는 프로그램이 입력 파일이 존재하지 않을 때 오류 메시지를 출력하는지 확인하는 것뿐입니다.
중요한 테스트이지만,
가장 중요한 테스트는 아닐 수 있습니다.
이제 프로그램이 파일에서 찾은 일치 항목을 실제로 출력하는지 테스트해 보겠습니다!

프로그램이 _반환해야 하는_ 내용을 알 수 있는 콘텐츠를 가진 파일이 필요합니다.
이를 통해 코드에서 이 기대 사항을 확인할 수 있습니다.
한 가지 방법은 프로젝트에 사용자 정의 콘텐츠가 있는 파일을 추가하고 테스트에서 사용하는 것입니다.
또는 테스트에서 임시 파일을 생성하는 것입니다.
이 튜토리얼에서는
후자의 접근 방식을 살펴보겠습니다.
주로 유연성이 높기 때문이며 다른 경우에도 작동합니다.
예를 들어, 파일을 변경하는 프로그램을 테스트할 때입니다.

이러한 임시 파일을 생성하려면
[`assert_fs`] crate를 사용할 것입니다.
`Cargo.toml`의 `dev-dependencies`에 추가하겠습니다:

```toml
{{#include testing/Cargo.toml:19}}
```

[`assert_fs`]: https://docs.rs/assert_fs

다음은 다른 테스트 케이스 아래에 작성할 수 있는 새로운 테스트 케이스입니다.
먼저 임시 파일을 생성하고
(이름이 지정되어 있으므로 경로를 가져올 수 있도록),
그 안에 텍스트를 채우고,
그런 다음 프로그램을 실행하여
올바른 출력을 얻는지 확인합니다.
`file`이 범위를 벗어날 때
(함수의 끝에서),
실제 임시 파일은 자동으로 삭제됩니다.

```rust,ignore
{{#include testing/tests/cli.rs:17:32}}
```

<aside class="exercise">

**독자를 위한 연습:**
패턴으로 빈 문자열을 전달하는 경우 통합 테스트를 추가합니다.
필요에 따라 프로그램을 조정합니다.

</aside>

## 테스트할 내용은 무엇인가?

통합 테스트를 작성하는 것은 분명 재미있지만,
시간이 오래 걸리고 애플리케이션의 동작이 변경될 때마다 업데이트해야 합니다.
시간을 효율적으로 사용하려면 테스트할 내용을 신중하게 고려해야 합니다.

일반적으로 사용자가 관찰할 수 있는 모든 유형의 동작에 대한 통합 테스트를 작성하는 것이 좋습니다.
즉, 모든 경계 사례를 다루어야 하는 것은 아닙니다.
다양한 유형의 예제를 가지고 경계 사례를 단위 테스트로 처리하는 것이 일반적으로 충분합니다.

또한 직접 제어할 수 없는 것에 집중하지 않는 것이 좋습니다.
예를 들어, `--help`의 정확한 레이아웃을 테스트하는 것은 생성이 자동화되기 때문에 좋지 않습니다.
대신, 특정 요소가 존재하는지 확인하는 것만으로도 충분합니다.

프로그램의 특성에 따라 더 많은 테스트 기법을 추가할 수도 있습니다.
예를 들어, 프로그램의 일부를 추출하고 단위 테스트를 작성하면서 모든 경계 사례를 고려해야 하는 경우 [`proptest`](https://docs.rs/proptest)를 사용해 볼 수 있습니다.
임의의 파일을 소비하고 분석하는 프로그램이라면 [fuzzer](https://rust-fuzz.github.io/book/introduction.html)를 작성하여 경계 사례에서 버그를 찾는 것이 좋습니다.

<aside>

**참고:**
이 장에서 사용된 전체 실행 가능한 소스 코드는
[이 책의 저장소](https://github.com/rust-cli/book/tree/master/src/tutorial/testing)에서 찾을 수 있습니다.

</aside>
